{
    "changeLanguageButton.language.en": "Английский",
    "changeLanguageButton.language.ru": "Русский",

    "navbar.link.docs": "Документация",
    "navbar.link.blog": "Блог",

    "hero.subtitle.theFramework": "Фреймворк для пользовательских веб-интерфейсов",
    "hero.button.learnCoreact": "Изучить Coreact",
    "hero.button.readBlog": "Читать блог",

    "welcome.title.welcome": "Добро пожаловать в сообщество Coreact",
    "welcome.button.getStarted": "Начать",

    "docsSidebar.link.overview": "Обзор",
    "docsSidebar.header.coreModules": "ОСНОВНЫЕ МОДУЛИ",
    "docsSidebar.link.rendering": "Рендеринг",
    "docsSidebar.link.styling": "Стилизация",
    "docsSidebar.link.stateManagement": "Управление состоянием",
    "docsSidebar.link.routing": "Маршрутизация",

    "blogBreadcrumb.link.home": "Главная",
    "blogBreadcrumb.link.blog": "Блог",

    "section.heading.createUI": "Создавайте интерфейсы из компонентов",
    "section.text.coreactLets": "Coreact позволяет создавать пользовательские интерфейсы из отдельных частей, называемых компонентами. Создавайте свои собственные компоненты Coreact, такие как Thumbnail, LikeButton и Video, а затем объединяйте их в целые экраны, страницы и приложения.",
    "section.text.whetherYou": "Неважно, работаете ли вы в одиночку или с тысячами других разработчиков — использовать Coreact одинаково удобно. Он создан для того, чтобы вы могли бесшовно объединять компоненты, написанные разными людьми, командами и организациями.",

    "notFoundPage.link.home": "Главная",
    "notFoundPage.heading.notFound": "Страница не найдена",
    "notFoundPage.text.thisPage": "Эта страница не существует.",

    "introducingCoreact.articleTitle": "Знакомьтесь с Coreact",
    "introducingCoreact.heading.title": "Знакомьтесь с Coreact: новый способ создавать веб-приложения",
    "introducingCoreact.badge.announcement": "анонс",
    "introducingCoreact.badge.release": "релиз",
    "introducingCoreact.heading.welcome": "Добро пожаловать в Coreact",
    "introducingCoreact.paragraph.intro": "Рад представить Coreact — новый фреймворк, созданный для того, чтобы сделать веб-разработку интуитивно понятной и эффективной. Coreact объединяет лучшие черты современных веб-фреймворков с упором на производительность и удобство для разработчиков.",
    "introducingCoreact.heading.why": "Почему Coreact?",
    "introducingCoreact.paragraph.whyIntro": "Я создавал Coreact, исходя из нескольких ключевых принципов:",
    "introducingCoreact.list.performance.title": "Производительность:",
    "introducingCoreact.list.performance.desc": "Создан с нуля с учетом высокой производительности",
    "introducingCoreact.list.simplicity.title": "Простота:",
    "introducingCoreact.list.simplicity.desc": "Интуитивно понятный API, который легко выучить",
    "introducingCoreact.list.flexibility.title": "Гибкость:",
    "introducingCoreact.list.flexibility.desc": "Создавайте всё — от простых сайтов до сложных приложений",
    "introducingCoreact.list.modern.title": "Современность:",
    "introducingCoreact.list.modern.desc": "Использует новейшие веб-стандарты и лучшие практики",
    "introducingCoreact.heading.gettingStarted": "Начало работы",
    "introducingCoreact.paragraph.gettingStarted": "Чтобы начать работу с Coreact, изучите эту документацию. Жду с нетерпением, что вы создадите!",
    "introducingCoreact.heading.whatsNext": "Что дальше?",
    "introducingCoreact.paragraph.whatsNext": "У меня захватывающие планы: серверный рендеринг, генерация статических сайтов и многое другое. Следите за обновлениями!",
    "introducingCoreact.link.backToBlog": "Назад к блогу",

    "coreactPerfOpt.articleTitle": "Оптимизация производительности в Coreact",
    "coreactPerfOpt.heading.title": "Оптимизация производительности в Coreact: разработан для скорости",
    "coreactPerfOpt.badge.performance": "производительность",
    "coreactPerfOpt.badge.framework": "фреймворк",
    "coreactPerfOpt.heading.philosophy": "Философия производительности Coreact",
    "coreactPerfOpt.paragraph.intro": "В основе Coreact — стремление к высокой производительности. В отличие от других фреймворков, где оптимизация добавляется постфактум, Coreact изначально проектировался с учетом скорости и эффективности. Вот как это реализовано:",
    "coreactPerfOpt.h3.virtualDom": "1. Облегчённый виртуальный DOM",
    "coreactPerfOpt.paragraph.virtualDom": "Виртуальный DOM в Coreact невероятно легковесен, с минимальными накладными расходами и максимальной эффективностью. Алгоритм согласования оптимизирован для частых сценариев обновления, что снижает количество лишних операций с DOM.",
    "coreactPerfOpt.h3.stateManagement": "2. Эффективное управление состоянием",
    "coreactPerfOpt.paragraph.stateManagement": "Хук useState в Coreact минимизирует количество повторных рендеров. Обновления состояния группируются и оптимизируются для предотвращения лишних обновлений компонентов.",
    "coreactPerfOpt.h3.treeShaking": "3. Поддержка Tree Shaking",
    "coreactPerfOpt.paragraph.treeShaking": "Модульная архитектура Coreact отлично сочетается с современными сборщиками и устраняет неиспользуемый код. В продакшн-сборку попадает только то, что реально используется.",
    "coreactPerfOpt.h3.memoryManagement": "4. Управление памятью",
    "coreactPerfOpt.paragraph.memoryManagement": "Coreact включает систему управления памятью, предотвращающую утечки. Слушатели событий и подписки автоматически удаляются при размонтировании компонентов.",
    "coreactPerfOpt.h3.eventHandling": "5. Оптимизированная обработка событий",
    "coreactPerfOpt.paragraph.eventHandling": "Используется делегирование событий для минимизации количества слушателей. Это улучшает использование памяти и производительность, особенно для больших списков и интерактивных элементов.",
    "coreactPerfOpt.heading.realWorld": "Производительность в реальных условиях",
    "coreactPerfOpt.paragraph.realWorld": "В тестах Coreact стабильно превосходит крупные фреймворки по ключевым метрикам:",
    "coreactPerfOpt.list.smallerBundle": "Меньший размер сборки",
    "coreactPerfOpt.list.fasterRender": "Более быстрое начальное отображение",
    "coreactPerfOpt.list.lowerMemory": "Меньшее потребление памяти",
    "coreactPerfOpt.list.efficientUpdates": "Более эффективные обновления",
    "coreactPerfOpt.heading.bestPractices": "Лучшие практики для максимальной производительности",
    "coreactPerfOpt.h3.minimizeRerenders": "1. Минимизируйте повторные рендеры",
    "coreactPerfOpt.paragraph.minimizeRerenders": "Структурируйте компоненты и состояние так, чтобы избежать ненужных рендеров. Поднимайте состояние вверх только при необходимости и используйте локальное состояние для изолированных обновлений.",
    "coreactPerfOpt.h3.optimizeStructure": "2. Оптимизируйте структуру компонентов",
    "coreactPerfOpt.paragraph.optimizeStructure": "Делайте компоненты небольшими и узкоспециализированными. Это позволяет алгоритму согласования Coreact работать эффективнее.",
    "coreactPerfOpt.h3.lazyLoading": "3. Ленивые загрузки",
    "coreactPerfOpt.paragraph.lazyLoading": "Используйте динамические импорты для разбиения кода и загрузки компонентов по мере необходимости.",
    "coreactPerfOpt.link.backToBlog": "Назад к блогу",

    "whyIBuilt.articleTitle": "Почему я создал этот фреймворк",
    "whyIBuilt.heading.title": "Почему я создал этот фреймворк",
    "whyIBuilt.badge.state": "состояние",
    "whyIBuilt.badge.framework": "фреймворк",
    "whyIBuilt.paragraph.intro1": "Когда я начал разрабатывать современные веб-приложения, мне понравилась мощь React и его экосистемы — но со временем я начал замечать повторяющиеся шаблоны. Шаблонный код накапливался. Инструменты замедляли работу. И я всё чаще выбирал более лёгкие решения, которыми проще было управлять.",
    "whyIBuilt.paragraph.intro2": "Тогда я задал себе вопрос: что, если свести опыт фронтенд-разработки только к самому необходимому?",
    "whyIBuilt.paragraph.intro3": "Этот вопрос и привёл к созданию фреймворка.",
    "whyIBuilt.heading.simplicity": "Простота прежде всего",
    "whyIBuilt.paragraph.simplicity1": "Я считаю, что большинству SPA не нужно 1000+ зависимостей, бесконечные конфигурации Babel или громоздкий webpack.",
    "whyIBuilt.paragraph.simplicity2": "Мой фреймворк предлагает:",
    "whyIBuilt.list.components": "Компоненты через обычные функции и JSX",
    "whyIBuilt.list.styling": "Стилизация первого класса с утилитарными классами в стиле Tailwind",
    "whyIBuilt.list.state": "Встроенное управление глобальным состоянием",
    "whyIBuilt.list.router": "Лёгкий роутер на основе History API",
    "whyIBuilt.paragraph.simplicity3": "Всё это — почти без конфигурации и с простой файловой структурой.",
    "whyIBuilt.heading.familiarTools": "Основан на знакомых инструментах",
    "whyIBuilt.paragraph.familiarTools1": "Я не изобретал колесо заново. Я опирался на инструменты, которые уже нравятся разработчикам:",
    "whyIBuilt.list.vite": "Vite — для моментальной обратной связи и быстрых сборок",
    "whyIBuilt.list.ts": "TypeScript — безопасность без компромиссов",
    "whyIBuilt.list.jsx": "JSX — выразительный и декларативный UI",
    "whyIBuilt.paragraph.familiarTools2": "Вы получаете привычный опыт разработки без лишней нагрузки.",
    "whyIBuilt.heading.whosItFor": "Кому подойдёт?",
    "whyIBuilt.paragraph.whosItFor1": "Этот фреймворк идеально подойдёт, если вы хотите:",
    "whyIBuilt.list.learnFrontend": "Изучить основы фронтенда без сложности фреймворков",
    "whyIBuilt.list.internalTools": "Создать внутренние инструменты, дашборды или лёгкие SPA",
    "whyIBuilt.list.fullControl": "Создавать быстро, с полным контролем и без лишнего",
    "whyIBuilt.paragraph.whosItFor2": "Надеюсь, вам будет так же приятно пользоваться им, как мне было приятно его разрабатывать.",
    "whyIBuilt.link.backToBlog": "Назад к блогу",

    "docsPage.heading.gettingStarted": "Начало",
    "docsPage.paragraph.welcome": "Добро пожаловать в официальную документацию лёгкого фронтенд-фреймворка. Это руководство — ваш старт в создании современных веб-приложений с чётким разделением логики и представления, компонентным рендерингом и встроенной поддержкой стилизации, роутинга и управления состоянием.",
    "docsPage.paragraph.frameworkDescription": "Будь то одностраничное приложение (SPA), дашборд или статический сайт, этот фреймворк предоставляет вам необходимые инструменты без излишков.",
    "docsPage.heading.installation": "Установка",
    "docsPage.paragraph.installation": "Чтобы начать использовать фреймворк, клонируйте репозиторий и установите зависимости с помощью следующих команд:",
    "docsPage.paragraph.developmentServer": "Это запустит сервер разработки и автоматически обновит браузер при изменениях. Фреймворк использует современные инструменты (Vite, TypeScript), обеспечивая молниеносные сборки и эффективный процесс разработки.",
    "docsPage.heading.projectStructure": "Структура проекта",
    "docsPage.paragraph.projectStructure": "Пользовательский код приложения находится в папке /src/app. Все остальные папки содержат внутреннюю логику выполнения или сгенерированный код и не должны редактироваться вручную.",
    "docsPage.paragraph.separationOfLogic": "Такое разделение позволяет обновлять внутренности фреймворка независимо от логики вашего проекта и поддерживать чистую среду разработки.",
    "docsPage.heading.whatsNext": "Что дальше?",
    "docsPage.paragraph.exploreCoreModules": "Изучите основные модули фреймворка:",
    "docsPage.link.rendering": "Рендеринг",
    "docsPage.link.renderingDescription": "Создавайте компоненты и работайте с JSX.",
    "docsPage.link.styling": "Стилизация",
    "docsPage.link.stylingDescription": "Используйте утилитарные классы в стиле Tailwind.",
    "docsPage.link.stateManagement": "Управление состоянием",
    "docsPage.link.stateManagementDescription": "Общий реактивный стейт по всему приложению.",
    "docsPage.link.routing": "Маршрутизация",
    "docsPage.link.routingDescription": "Динамическая клиентская навигация.",
    "docsPage.link.nextRendering": "Далее: Рендеринг",

    "blogPage.heading.title": "Блог",
    "blogPage.paragraph.intro": "Читайте последние новости, руководства и технические статьи по фреймворку Coreact.",
    "blogPage.article.performance.title": "Оптимизация производительности в Coreact",
    "blogPage.article.performance.summary": "Советы по максимальному ускорению и эффективности ваших приложений на Coreact.",
    "blogPage.article.performance.tag1": "производительность",
    "blogPage.article.performance.tag2": "оптимизация",
    "blogPage.article.whyBuilt.title": "Почему я создал этот фреймворк",
    "blogPage.article.whyBuilt.summary": "Взгляд на мотивацию и видение, стоящие за Coreact.",
    "blogPage.article.whyBuilt.tag1": "мотивация",
    "blogPage.article.whyBuilt.tag2": "дизайн",
    "blogPage.article.introducing.title": "Представляем Coreact: новый способ создания веб-приложений",
    "blogPage.article.introducing.summary": "Рад представить Coreact — современный фреймворк для создания веб-приложений с акцентом на производительность и удобство для разработчиков.",
    "blogPage.article.introducing.tag1": "анонс",
    "blogPage.article.introducing.tag2": "релиз",

    "docsRendering.heading.title": "Рендеринг",
    "docsRendering.paragraph.intro": "Модуль рендеринга — это сердце фреймворка. Он позволяет писать компоненты в декларативном стиле с использованием JSX, делая логику интерфейса выразительной и интуитивно понятной.",
    "docsRendering.heading.definingComponents": "Определение компонентов",
    "docsRendering.paragraph.definingComponents": "Компонент — это функция на JavaScript (или TypeScript), возвращающая JSX. Это переиспользуемый строительный блок, определяющий, как должен выглядеть и вести себя интерфейс.",
    "docsRendering.paragraph.noClassSyntax": "Никаких классов или сложной модели жизненного цикла. Просто пишите функции, описывающие элементы интерфейса.",
    "docsRendering.paragraph.nesting": "Компоненты можно вкладывать друг в друга, передавать им свойства (props) или условно отображать. Если вы использовали React, вам всё покажется знакомым.",
    "docsRendering.heading.conditionalRendering": "Условная отрисовка",
    "docsRendering.paragraph.conditionalRendering": "Условная отрисовка полезна для переключения контента интерфейса на основе логики приложения, действий пользователя или изменения состояния.",
    "docsRendering.paragraph.conditionalRendering2": "Это позволяет показывать или скрывать части приложения без ручного управления стилями отображения. Особенно удобно для потоков аутентификации, индикаторов загрузки и персонализации интерфейса.",
    "docsRendering.heading.useState": "Хук useState",
    "docsRendering.paragraph.useState": "useState — самый простой способ добавить интерактивность в компоненты. Он возвращает значение состояния и функцию для его обновления.",
    "docsRendering.paragraph.useState2": "Каждый раз при вызове setCount компонент перерисовывается с новым значением. Это делает useState идеальным для отслеживания локальных значений интерфейса, таких как поля формы, переключатели или счётчики.",
    "docsRendering.heading.useEffect": "Хук useEffect",
    "docsRendering.paragraph.useEffect": "Хук useEffect позволяет выполнять побочные эффекты после отрисовки компонента. Это может быть загрузка данных, вывод в консоль или взаимодействие с DOM браузера.",
    "docsRendering.paragraph.useEffect2": "Хук запускается после каждой отрисовки, когда меняются зависимости (в данном случае value). Эффекты изолированы от отрисовки, что позволяет чисто управлять асинхронным поведением без блокировки интерфейса.",
    "docsRendering.link.nextStyling": "Далее: Стилизация",

    "docsRouting.heading.title": "Маршрутизация",
    "docsRouting.paragraph.intro": "Маршрутизация — базовая функция для любого одностраничного приложения (SPA). Она позволяет перемещаться между страницами, сохранять состояние приложения и обеспечивать быструю, плавную работу без полной перезагрузки. Этот фреймворк включает лёгкую, но мощную систему маршрутизации, простую в использовании и гибкую для реальных задач.",
    "docsRouting.heading.clientSide": "Что такое клиентская маршрутизация?",
    "docsRouting.paragraph.clientSide": "В отличие от традиционных сайтов, где навигация вызывает полную перезагрузку страницы, клиентская маршрутизация обновляет URL и динамически отображает соответствующий компонент — всё на одной странице. Это делает приложение быстрым и интерактивным.",
    "docsRouting.paragraph.clientSide2": "Например, при переходе по ссылке на `/about`, приложение не перезагружает всю страницу. Вместо этого маршрутизатор обновляет историю браузера и заменяет дерево компонентов.",
    "docsRouting.heading.definingRoutes": "Определение маршрутов",
    "docsRouting.paragraph.definingRoutes": "Чтобы начать работу с маршрутизацией, определите таблицу маршрутов, сопоставляющую пути URL с компонентами. Эта таблица служит картой навигации вашего приложения:",
    "docsRouting.paragraph.createRouter": "Затем используйте createRouter() для создания реактивного экземпляра маршрутизатора, который отслеживает изменения и отображает нужную страницу:",
    "docsRouting.paragraph.currentPage": "Разместите <CurrentPage /> там, где должны отображаться маршрутизируемые представления — обычно внутри основного компонента макета.",
    "docsRouting.heading.programmatic": "Программная навигация",
    "docsRouting.paragraph.programmatic": "Вы можете инициировать переход между страницами из любого места приложения с помощью функции navigate(). Это удобно для отправки форм, обработки нажатий кнопок или логики редиректа после действия:",
    "docsRouting.paragraph.programmatic2": "Это обновляет URL и отображает новый маршрут без перезагрузки. Всё происходит быстро, а состояние других компонентов сохраняется.",
    "docsRouting.heading.links": "Навигационные ссылки",
    "docsRouting.paragraph.links": "Для стандартной навигации между страницами используйте встроенный компонент `Link`. Он работает как тег `<a>`, но использует внутреннюю маршрутизацию фреймворка для избежания полной перезагрузки.",
    "docsRouting.paragraph.links2": "`Link` гарантирует корректное обновление истории браузера, сохранение позиций прокрутки и мгновенные переходы. Это предпочтительный способ создания меню, вкладок и встроенной навигации.",
    "docsRouting.heading.dynamic": "Динамические параметры",
    "docsRouting.paragraph.dynamic": "Иногда требуется сопоставить маршруты с переменными сегментами — например, для отображения профиля пользователя по ID. Вы можете определить динамические пути следующим образом:",
    "docsRouting.paragraph.useParams": "Чтобы получить доступ к параметру `:id` внутри компонента `UserProfile`, используйте хук `useParams()`:",
    "docsRouting.paragraph.useParams2": "Это упрощает создание страниц вроде `/products/:slug`, `/posts/:id` или любых маршрутов, зависящих от динамического ввода.",
    "docsRouting.heading.tips": "Советы по эффективной маршрутизации",
    "docsRouting.list.useLink": "Всегда используйте компонент `Link` вместо `<a>` для внутренней навигации.",
    "docsRouting.list.groupRoutes": "Группируйте связанные маршруты и компоненты логически, чтобы сохранить порядок в коде.",
    "docsRouting.list.dynamicParams": "Используйте динамические параметры умеренно и проверяйте их при получении данных извне.",
    "docsRouting.list.wrapRouter": "Оборачивайте маршрутизатор в компоненты макета для сохранения структуры на всех страницах.",
    "docsRouting.link.backOverview": "Назад к обзору",

    "docsState.heading.title": "Управление состоянием",
    "docsState.paragraph.intro": "Хотя useState отлично подходит для управления локальным состоянием компонентов, в реальных приложениях часто требуется глобальное состояние — данные, к которым должен быть доступ и возможность обновления в разных, не связанных друг с другом компонентах.",
    "docsState.heading.whyGlobal": "Зачем нужно глобальное состояние?",
    "docsState.paragraph.scenarios": "Представьте следующие сценарии:",
    "docsState.list.sidebar": "Открытие боковой панели из кнопки в шапке и её закрытие из самой панели.",
    "docsState.list.auth": "Управление состоянием аутентификации пользователя в нескольких компонентах.",
    "docsState.list.cart": "Сохранение содержимого корзины при навигации между страницами.",
    "docsState.paragraph.storeIntro": "Управление этим через прокидывание props или подъем состояния усложняется и становится подверженным ошибкам. Здесь пригодится управление состоянием на основе хранилищ (store).",
    "docsState.heading.createStore": "Создание хранилища",
    "docsState.paragraph.createStore": "Вы можете определить реактивное глобальное состояние с помощью `createStore`:",
    "docsState.paragraph.useStore": "Затем использовать его в любом компоненте:",
    "docsState.paragraph.storeBehavior": "Хранилище работает как общий useState. Любой компонент, использующий хук хранилища, автоматически перерисовывается при изменении значения.",
    "docsState.heading.bestPractices": "Лучшие практики",
    "docsState.list.globalData": "Используйте глобальное состояние для данных на уровне всего приложения, а не для UI одного компонента.",
    "docsState.list.focusedStores": "Делайте хранилища узкоспециализированными. Например, useUser() для авторизации, useCart() для магазина и т.д.",
    "docsState.list.customHooks": "Оборачивайте логику хранилища в пользовательские хуки, если нужно производное состояние, мемоизация или действия.",
    "docsState.link.nextRouting": "Далее: Маршрутизация",

    "docsStyling.heading.title": "Стилизация",
    "docsStyling.paragraph.intro": "Стилизация в этом фреймворке основана на системе utility-first, вдохновлённой Tailwind CSS. Она позволяет разработчикам писать выразительные, лёгкие стили прямо в JSX без необходимости создания или поддержки отдельных CSS-файлов.",
    "docsStyling.heading.utilityFirst": "Почему utility-first стилизация?",
    "docsStyling.paragraph.utilityFirst": "Традиционный CSS требует создания и управления множеством уникальных классов, поддержки больших таблиц стилей и постоянного переключения между разметкой и стилями. Utility-first CSS решает это, позволяя собирать стили из стандартных утилит прямо в коде.",
    "docsStyling.paragraph.insteadOf": "Вместо этого:",
    "docsStyling.paragraph.writeThis": "Можно написать так:",
    "docsStyling.paragraph.result": "Результат? Меньше ментальной нагрузки, меньший размер CSS и молниеносная разработка стилей.",
    "docsStyling.heading.commonUtilities": "Распространённые утилиты",
    "docsStyling.list.typography": "Типографика: text-sm, text-lg, font-semibold, leading-tight",
    "docsStyling.list.color": "Цвета: text-blue-600, bg-gray-100, hover:bg-blue-700, border-red-500",
    "docsStyling.list.spacing": "Отступы: m-4, mt-2, px-6, gap-4",
    "docsStyling.list.layout": "Макет: flex, grid, items-center, justify-between",
    "docsStyling.list.effects": "Эффекты: shadow, rounded, hover:scale-105, transition",
    "docsStyling.paragraph.combine": "Вы можете комбинировать их для создания интерфейсов без написания пользовательского CSS:",
    "docsStyling.heading.responsive": "Адаптивность",
    "docsStyling.paragraph.breakpoints": "По умолчанию утилиты применяются ко всем экранам. Вы можете добавлять префиксы для адаптивного поведения:",
    "docsStyling.paragraph.responsive": "Это создаст вертикальную компоновку на мобильных и горизонтальную на средних и больших экранах.",
    "docsStyling.heading.theming": "Темизация и значения по умолчанию",
    "docsStyling.paragraph.defaultStyles": "Стили по умолчанию загружаются из `/src/styles` и включают:",
    "docsStyling.list.preflight": "CSS Preflight (сброс стилей)",
    "docsStyling.list.themeVars": "Корневые переменные темы (цвета, отступы, шрифты)",
    "docsStyling.paragraph.customize": "Их можно настроить или расширить под ваш бренд или систему дизайна.",
    "docsStyling.link.nextState": "Далее: Управление состоянием"
}
